![img](./resources/segement.png)



**代码段(.text)**，也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。

**数据段，**包括已初始化的数据段(.data)和未初始化的数据段（.bss），前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。

**堆栈段**分为堆和栈：

- 堆（Heap）：用来存储程序运行时分配的变量。

堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free          等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。

- 栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。

栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。

栈的基本操作： PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶； POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。

 **堆和栈的区别：**

**1.分配和管理方式不同 ：**

- 堆是动态分配的，其空间的分配和释放都由程序员控制。

- 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。

- - 静态分配由编译器完成，比如局部变量的分配。
  - 动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。

**2.产生碎片不同：**

- 对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。
- 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。

**3.生长方向不同：**

- 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。
- 栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。